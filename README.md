# World Card AI ğŸƒ

> A terminal card survival game powered by AI. Every world is unique, every choice matters, and death is never the end.

![](./images/loading.png)

![](./images/gameplay.png)

---

## Overview

**World Card AI** is a [Reigns](https://store.steampowered.com/app/474750/Reigns/)-inspired terminal game where you rule a kingdom by swiping left or right on decision cards. Unlike traditional card games, every world and every card is generated by Large Language Models â€” your kingdom's story, NPCs, politics, and crises are unique to each playthrough.

The game runs entirely in your terminal using the [Textual](https://textual.textualize.io/) framework and communicates with any OpenRouter-compatible LLM via LangChain.

---

## Features

- ğŸŒ **AI-Generated Worlds** â€” The Architect LLM designs the world: its era, factions, characters, stats, seasons, and an entire branching plot graph.
- ğŸ“œ **Dynamic Storytelling** â€” The Writer LLM generates a fresh deck of decision cards each season, informed by your current state: stats, active events, tags, and plot progress.
- ğŸ§¬ **Season-Based Life Cycle** â€” The game is structured around seasons (Spring â†’ Summer â†’ Autumn â†’ Winter). Each season starts with a narrative introduction. Death skips you to the next season; your karma and story choices carry forward.
- âš”ï¸ **Function-Calling Actions** â€” Card choices execute typed functions (`update_stat`, `add_event`, `enable_npc`, `add_tag`, etc.) rather than raw stat diffs, enabling rich and composable effects.
- ğŸ•¸ï¸ **Plot DAG** â€” The Architect defines a branching macro-story graph with multiple endings. Plot nodes unlock and fire as you meet conditions throughout your reign.
- ğŸ“… **Event System** â€” Four event types: `phase` (multi-stage), `progress` (goal-based), `timed` (deadline-driven), and `condition` (trigger-based). Events persist across seasons.
- â™¾ï¸ **Reincarnation** â€” On death, you are reborn in the next season. Tags and karma carry over. Your resurrection mechanic is defined by the AI when the world is created.
- ğŸ® **Demo Mode** â€” Play offline without an API key using a pre-built medieval kingdom world.

---

## Screenshots

> _(Terminal-based UI â€” see it live by running the game!)_

---

## Requirements

- Python 3.10+
- An [OpenRouter](https://openrouter.ai/) API key (for full AI mode)

---

## Setup

### 1. Clone the repository

```bash
git clone https://github.com/your-username/world-card-ai.git
cd world-card-ai
```

### 2. Install dependencies

```bash
pip install -r requirements.txt
```

### 3. Configure environment

Copy the example `.env` file and fill in your credentials:

```bash
cp .env.example .env
```

Edit `.env`:

```env
OPENROUTER_API_KEY=sk-or-...

# Optional: override the default model names
HEAVY_MODEL=google/gemini-2.5-pro     # Used by the Architect (world gen)
FAST_MODEL=google/gemini-2.5-flash   # Used by the Writer (card gen)
```

If `HEAVY_MODEL` or `FAST_MODEL` are not set, the defaults above are used.

---

## Running

### Full AI Mode

```bash
python main.py
```

Launches the world creation screen. The Architect LLM will generate a unique world based on your chosen theme. Then the Writer LLM will generate cards every season, live during gameplay.

### Demo Mode (no API key required)

```bash
python main.py --demo
```

Loads the pre-built **Kingdom of Ardenvale** world and uses a hand-crafted card pool. No network calls are made.

---

## Controls

| Key | Action |
|-----|--------|
| `â†` / `A` | Swipe left |
| `â†’` / `D` | Swipe right |
| `Q` | Quit |
| `~` | Toggle cheat/debug panel |

---

## Architecture

```
world-card-ai/
â”œâ”€â”€ main.py              # Entry point + CLI args
â”œâ”€â”€ agents/              # LLM agents
â”‚   â”œâ”€â”€ architect.py     # World generation (streaming, sectioned output)
â”‚   â”œâ”€â”€ writer.py        # Card generation (batch per season)
â”‚   â”œâ”€â”€ schemas.py       # Pydantic models: WorldGenSchema, CardDef, ...
â”‚   â”œâ”€â”€ client.py        # OpenRouter LLM client (heavy/fast models)
â”‚   â””â”€â”€ prompt_loader.py # Jinja2 template renderer
â”œâ”€â”€ prompts/             # Jinja2 prompt templates
â”‚   â”œâ”€â”€ architect_system.j2
â”‚   â”œâ”€â”€ architect_user.j2
â”‚   â”œâ”€â”€ writer_system.j2
â”‚   â””â”€â”€ writer_user.j2
â”œâ”€â”€ game/                # Core game engine and state
â”‚   â”œâ”€â”€ engine.py        # GameEngine: card draw, resolution, death, plot
â”‚   â”œâ”€â”€ state.py         # GlobalBlackboard (Pydantic): all game state
â”‚   â”œâ”€â”€ events.py        # Event models (phase, progress, timed, condition)
â”‚   â”œâ”€â”€ job_queue.py     # Async card-generation job queue
â”‚   â”œâ”€â”€ demo.py          # Pre-built demo world + card pool
â”‚   â””â”€â”€ cost.py          # Token cost tracker
â”œâ”€â”€ cards/               # Card models and logic
â”‚   â”œâ”€â”€ models.py        # Card, ChoiceCard, InfoCard, Choice
â”‚   â”œâ”€â”€ deck.py          # WeightedDeque (priority-based card deck)
â”‚   â”œâ”€â”€ resolver.py      # ActionExecutor: applies function calls to state
â”‚   â””â”€â”€ validator.py     # Validates + converts CardDef â†’ Card
â”œâ”€â”€ death/               # Death and resurrection system
â”‚   â””â”€â”€ loop.py          # DeathLoop: detects stat boundaries, karma
â”œâ”€â”€ story/               # Plot graph (DAG)
â”‚   â””â”€â”€ dag.py           # MacroDAG: node activation, ends, firing
â””â”€â”€ ui/                  # Textual TUI
    â”œâ”€â”€ app.py           # WorldCardApp (root)
    â”œâ”€â”€ screens/         # Screens: loading, world, game, cheat, ending
    â””â”€â”€ widgets/         # Widgets: card view, stats bar, deck counter, timeline, ...
```

---

## Game Loop

1. **World Creation** â€” The Architect streams a `WorldGenSchema`: stats, NPCs, relationships, seasons, tags, and a plot DAG with 3â€“4 endings.
2. **Season Start (Day 1)** â€” The Writer generates a full batch:
   - 7 common choice cards
   - 1 Welcome or Reborn info card (first life / after death)
   - 1 Season narrative card
   - 2Ã— N death cards (one per stat Ã— min/max boundary)
3. **Playing** â€” You are shown one card per action. Swipe left or right to execute the choice's function calls (stat changes, events, NPC state, tags).
4. **Events** â€” Active events persist across seasons and display in the sidebar. Some unlock new cards when they end.
5. **Plot** â€” After each action, plot conditions are checked. If met, the next plot node fires at week end, injecting a narrative card.
6. **Death** â€” If a stat hits 0 or 100, a pre-generated death card is shown. Swiping it triggers resurrection.
7. **Resurrection** â€” The calendar advances to the next season. Tags and karma carry over. A Reborn card narrates the transition.
8. **Ending** â€” Reaching an ending plot node switches to the ending screen.

---

## State Carried Across Lives

When you die and are reborn, the following state persists:

- âœ… Tags (acquired story flags)
- âœ… Karma (list of past life highlights)
- âœ… Plot nodes (already fired nodes remain fired)
- âœ… Life number

The following state is reset:

- âŒ Stats (return to 50)
- âŒ Active events
- âŒ NPC enable/disable state

---

Here is the structured markdown to-do list, sáº¿p.

## Project Tasks

* [ ] Save world
* [ ] Generate avatars and character images as SVGs using LLM (e.g., low poly style)
* [ ] Implement a mechanism to increase/decrease stats after each season
* [ ] Add an `assistant` NPC. This special NPC provides a third dialogue/action option (mapped to the Down arrow or `S` key) designed to balance the player's current stats. This should typically serve as the optimal choice among the three available options.
* [ ] Enable streaming for generated cards
* [ ] Add AI-generated hints prior to each season
* [ ] Implement an "undo last action" feature
* [ ] Update progression logic: Configure the system to save a user checkpoint at the beginning of each season rather than skipping directly to the next season
* [ ] A NPC should have a card to introduce them when they are first introduced
* [ ] Player chacracter and NPCs should age each season, and the LLM should be aware of this when generating cards (e.g., "Your trusted advisor is now an old man nearing the end of his life. Do you...")
* [ ] Add a "legacy" system where certain achievements or milestones from past lives can unlock special cards or options in future lives (e.g., "Because you successfully defended the kingdom from a dragon in a past life, you have the option to call upon the Dragon's Aid in this life")
* [ ] Use Lua as the scripting language for card effects instead of Python eval.
---

Would you like me to expand any of these items into smaller, actionable sub-tasks?

## Contributing

Pull requests are welcome. Please open an issue first for major feature changes.

---

## License

MIT
